\documentclass{scrartcl}

\usepackage{includes}
\usepackage{iris}
\usepackage{hyperref}

\title{Notes on reasoning about monotonicity in (concurrent) separation logic}
\author{Amin Timany}

\begin{document}

\maketitle

\begin{abstract}
  These short notes describe an approach to reason about monotonicity
  in general in a separation logic. We do this by defining a new
  resource which can only be updated in a monotone way. This resource
  allows one to take a snapshot at any moment and use this snapshot to
  reason, at any later point in time, that the current value of the
  resource is greater than or equal to the token snapshot. The
  resource construction we present is essentially a partial
  commutative monoid (\PCM{}). Hence, any program logic where resources
  are defined in terms of partial commutative monoids can benefit from
  this development. Here we present the construction in the \Iris{}
  program logic.
\end{abstract}

\section{\PCM's as Resources}
The notion of resource is \Iris{} is defined as resource algebra
(\RA{}) which are very similar to \PCM's. We will pretend that \RA{}'s
are \PCM{}'s.
\paragraph{Extension Order} Every (partial) monoid $M$ gives rise to a
notion of order, $\extle{M}$, over the elements of the carrier set called
the \emph{extension order} of the monoid.
\[ a \extle{M} b \eqdef \exists c.\; b = a \cdot c \]
%
Notice that the axioms of monoid ensure that $\extle{M}$ is a preorder
relation.

\begin{remark}
  Despite \PCM's{} \RA's are not required to necessarily have a unit
  element. Hence, the extension order is stated slightly differently
  to ensure it is reflexive! In \Iris{} there is a canonical way of
  turning a non-unital \RA{} into a unital one.
\end{remark}

\newcommand{\mnat}{\mathbb{N}_{\mathit{max}}}

\begin{example}
  An example of a \PCM{} is $\mnat$ the monoid of
  natural numbers with $\mathit{max}$ as the monoid operation. The
  extension order $\extle{\mnat}$ corresponds to
  $\le$ on natural numbers. Notice that this monoid is idempotent. We
  will return to this point later.
\end{example}

\paragraph{Ownership of Resources and Separating Conjunction}
The proposition $\ownGhost{\gname}{a}$ means that we own resource $a$
under the name $\gname$. Names are used to distinguish different
instances of resources (we can own different resources for different
purposes). The general idea is that operation of the \PCM{}
internalizes and represents the separating conjunction in the
underlying model of logic.
\[
\ownGhost{\gname}{a \cdot b} \provesIff \ownGhost{\gname}{a} \ast \ownGhost{\gname}{b}
\]
Here $\provesIff$ is logical equivalence.

\paragraph{Partiality and Validity}
The partiality of the monoid operation $\cdot$ is captured by means of
a validity predicate $\valid{a}$. Only valid elements of the monoid
can be allocated and ownership of an element implies its validity.
\begin{mathpar}
  \inferH{own-alloc}{\valid{a}}{\upd \exists \gname.\; \ownGhost{\gname}{a}}
  \and
  \inferH{own-valid}{\ownGhost{\gname}{a}}{\valid{a}}
\end{mathpar}
The update modality, $\upd$ allows manipulation (allocation, update,
deallocation) of resources. This modality is orthogonal to the present
discussion and we will therefore not explain it any further.

\paragraph{Persistence}
Intuitively, A proposition is persistent if its underlying $a$ has the
property that $a \cdot a = a$. In this case, we say that $a$ is an
\emph{idempotent} element of the monoid. Ownership of idempotent
elements is persistent which implies duplicablity.
\[ \ownGhost{\gname}{a} \provesIff \ownGhost{\gname}{a} \ast \ownGhost{\gname}{a} \]
%
Elements of $\mnat$ are all idempotent and hence their ownership is
persistent and consequently duplicable.

\section{Authoritative Monoid and Monotonicity with respect to the
  Extension Order}
The authoritative monoid is designed for reasoning about distributing
resources. The idea is that a central location will keep track of a
resource (global knowledge) while fragments of the resource can be
distributed, \eg, among multiple threads. This can be used, \eg, to
state invariants about the internal representation of a data structure
which is shared among multiple threads.

The authoritative monoid $\authm(M)$ over a monoid $M$ is defined as
follows:
\begin{align*}
  |\authm(M)| \eqdef{}& \set{\authfull a \middle| a \in |M|}
  \cup \set{\authfrag a \middle| a \in |M|} \cup \set{\authfull\!\authfrag(a, b) \middle| a, b \in |M|} \cup \set{\bot}\\
  x \cdot_{M} y \eqdef{} &
  \begin{cases}
    \authfrag (a \cdot_{M} b) & x = \authfrag a \land y = \authfrag b\\
    \authfull\!\authfrag (a, b) & x = \authfull a \land y = \authfrag b\\
    \authfull\!\authfrag (a, b) & y = \authfull a \land x = \authfrag b\\
    \bot & \text{otherwise}
  \end{cases}
\end{align*}
The validity for elements of $\authm{M}$ is as described by the
following inference rules:
\begin{mathpar}
  \infer{\valid(a)}{\valid(\authfrag a)}
  \and
  \infer{\valid(a)}{\valid(\authfull a)}
  \and
  \infer{\valid(b) \and a \extle{M} b}{\valid(\authfull\!\authfrag (a, b))}
\end{mathpar}
That is, a combination of global and local knowledge is valid if and
only if the local knowledge is \emph{small} than the global knowledge
and the global knowledge (any by extension the local knowledge) is
valid. Therefore, $\authm(M)$ allows us to express and reason about
the relation between global and local knowledge:
\[ \ownGhost{\gname}{\authfull a} \ast \ownGhost{\gname}{\authfrag a}
  \proves b \extle{M} a \] Notice that by the definition above
$\authfrag{a}$ is an idempotent element of $\authm(M)$ if and only if
$a$ is an idempotent element of $M$.

\begin{example}\label{ex:auth-mnat}
  As an example of authoritative monoids consider
  $\authm{\mnat}$. This allows us to reason about monotonic increasing
  natural number values. For instance, we can use this monoid to
  reason about the value of a monotone counter. We simply need to
  demand (through an invariant) that the value $n$ stored in the
  counter is always the same as the global knowledge
  $\ownGhost{\gname}{n}$. Hence, by owning $\ownGhost{\gname}{m}$ and
  reading the value of the counter we can conclude that the read value
  is greater than or equal to $m$.
\end{example}

Therefore, in order to reason about monotonicity with respect to a
preorder relation $R$ in \Iris{} and other similar program logics it
suffices to have a resource with idempotent resources where the
extension order corresponds to $R$.

\section{The $\monom{R}$ \PCM{} and reasoning about monotonicity in
  general}
In this section we present the \PCM{} $\monom{R}$, a resource with
idempotent elements where the extension order corresponds to
$R$. Similar to Example~\ref{ex:auth-mnat}, $\monom{R}$ enables
reasoning about monotonicity with respect to the relation $R$.

The essential idea is to take the free join-semi-lattice completion of
$R$ as the \PCM{} where the operation is the least upper bound,
$\lub$.

\begin{definition}
  Let $R$ be a relation on a set $X$. We define the monoid $\monom{R}$
  as follows:
\begin{align*}
  |\monom{R}| \eqdef{}& \mathcal{P}^{\mathrm{fin}}(A)/\cong\\
  A \cong B \eqdef{}& \forall x \in X.\; (\exists a \in A.\; x \le a) \iff (\exists b \in B.\; x \le b)\\
  A \cdot B \eqdef{} & A \cup B\\
  \forall A.\; \valid{A}
\end{align*}
We define the function $\principal : X \to \monom{R}$ to map elements
of the set $X$ into their representatives in $\monom{R}$:
\[ \principal(a) = \set{a} \]
\end{definition}

\begin{lemma}[General properties of $\monom{R}$] \label{lem:monom-gen-prop}
  For any relation $R$ on set $X$ the following properties hold.
  \begin{enumerate}
  \item The construction $\monom{R}$ is a commutative monoid and hence
    a \PCM{}. That is,
    \begin{enumerate}
    \item the operation of $\monom{R}$, $\cdot_{\monom{R}}$, is
      associative and commutative
    \item $\emptyset$ is the unit element of this monoid
    \end{enumerate}
  \item For any $A \in \monom{R}$, $A$ is idempotent
  \item For any $a, b \in X$ and $A \in \monom{R}$, If $a ~R~ a$ holds
    then $\principal(a) \cdot_{\monom{R}} A = \principal(b)$ implies $a ~R~ b$
  \item If $R$ is transitive then for any $a, b \in X$, $a ~R~ b$
    implies $\principal(a)  \cdot_{\monom{R}} \principal(b) = \principal(b)$
  \item For any $a, b \in X$, $\principal(a) = \principal(b)$ implies $a ~R~ b$ and $b ~R~a$
  \end{enumerate}
\end{lemma}
\begin{proof}
  All properties follow easily from the definition above.
\end{proof}

\begin{lemma}[properties of $\monom{R}$ of preorder $R$]
  For any \textbf{preorder} relation $R$ on set $X$ the following
  properties hold.
  \begin{enumerate}
  \item The construction $\monom{R}$ is a commutative monoid and hence
    a \PCM{}. That is,
      \begin{enumerate}
      \item the operation of $\monom{R}$, $\cdot_{\monom{R}}$, is
        associative and commutative
        \item $\emptyset$ is the unit element of this monoid
      \end{enumerate}
    \item For any $A \in \monom{R}$, $A$ is idempotent
    \item For any $a, b \in X$, $a ~R~ b$ \textbf{if and only if} $\principal(a) \extle{\monom{R}} \principal(b)$
    \item For any $a, b \in X$, $a ~R~ b$ implies $\principal(a) \cdot \principal(b) = \principal(b)$
    \item For any $a, b \in X$, $\principal(a) = \principal(b)$ implies $a ~R~ b$ and $b ~R~a$
    \item If $R$ is antisymmetric then for any $a, b \in X$,
      $\principal(a) = \principal(b)$ implies $a = b$
    \end{enumerate}
\end{lemma}
\begin{proof}
  Follows immediately from Lemma~\ref{lem:monom-gen-prop}.
\end{proof}

\section{Use case: monotone references}
We have used the development above of $\monom{R}$ together with
authoritative monoid construction to construct monotone references.

We derive the following rules for monotone references:\footnote{We
  omit masks on the fancy update modality and weakest preconditions
  for simplicity.}
\begin{mathpar}
  \inferH{MonRefAlloc}{\loc \mapsto v}{\upd \loc \monmapsto{R}{\gname} \val}
  \and
  \inferH{MonRefDealloc}{\loc \monmapsto{R}{\gname} \val}{\loc \mapsto v \and \exists \prop.\; P \ast (\forall \valB.\; v R w \ast \prop \ast \loc \mapsto \valB \vsW \loc \monmapsto{R}{\gname} \valB)}
  \and
  \inferH{wpReadMonRef}{}{\hoare{\loc \monmapsto{R}{\gname} \val}{\deref
      \loc}{\var.\; \var = \val \ast \loc \monmapsto{R}{\gname} \val}}
  \and
  \inferH{wpWriteMonRef}{}{\hoare{\loc \monmapsto{R} \val \ast \val ~R~\valB}
    {\loc \gets \valB}{\var.\; \var = \TT \ast \loc \monmapsto{R} \valB}}
  \and
  \inferH{SnapShot}{\loc \monmapsto{R}{\gname} \val}{\atleast(\loc, \val)}
  \and
  \inferH{Recall}{\atleast(\loc, \val) \and \loc \monmapsto{R}{\gname} \valB}{\val ~R~ \valB}
  \and
  \inferH{Persistence}{}{\persistent{\atleast(\loc, \val)}}
\end{mathpar}
Here $\vsW$ is a shorthand for $\wand \upd$. The proposition
$\loc \monmapsto{R} \valB$ expresses ownership of monotone reference
$\loc$ with value $\valB$.

\end{document}


% LocalWords:  monotonicity unital monoid monoids invariants logics
% LocalWords:  preorder
